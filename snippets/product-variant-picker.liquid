// Find the updatePriceBasedOnSelections function and modify it to ensure it doesn't get overridden
function updatePriceBasedOnSelections(sectionId) {
  const options = getCurrentlySelectedOptions(sectionId);
  
  // Check if any option is not selected
  if (options.some(opt => opt === null)) {
    // Show price range if any option is not selected
    showPriceRange();
    return;
  }
  
  // Find the variant that matches all selected options
  const variant = findVariantFromOptions(options);
  
  // If no variant matches or variant not found, show price range
  if (!variant) {
    showPriceRange();
    return;
  }
  
  // Set a data attribute to remember that we have a specific price showing
  const priceContainer = document.querySelector('#price-{{ section.id }}');
  if (priceContainer) {
    priceContainer.setAttribute('data-showing-variant-price', 'true');
    priceContainer.setAttribute('data-variant-id', variant.id);
  }
  
  // Update price with the specific variant price
  const regularPriceElement = document.querySelector('#price-{{ section.id }} .price__regular .price-item--regular');
  if (regularPriceElement) {
    const regularPrice = formatPrice(variant.price);
    regularPriceElement.textContent = regularPrice;
  }
  
  // Handle compare at price if exists
  if (variant.compare_at_price && parseFloat(variant.compare_at_price) > parseFloat(variant.price)) {
    // Make sure we have the compare at price elements
    const compareContainer = document.querySelector('#price-{{ section.id }} .price__sale .price-item--regular');
    const saleContainer = document.querySelector('#price-{{ section.id }} .price__sale .price-item--sale');
    
    if (compareContainer) {
      compareContainer.textContent = formatPrice(variant.compare_at_price);
    }
    
    if (saleContainer) {
      saleContainer.textContent = formatPrice(variant.price);
    }
    
    // Make sure the price class has sale class
    if (priceContainer) {
      priceContainer.classList.add('price--on-sale');
    }
  } else {
    // Remove sale class if no longer on sale
    if (priceContainer) {
      priceContainer.classList.remove('price--on-sale');
    }
  }
}

// Modify the showPriceRange function to respect variant-specific prices
function showPriceRange() {
  if (!productData) return;
  
  const priceContainer = document.querySelector('#price-{{ section.id }}');
  if (!priceContainer) return;
  
  // Check if we're showing a specific variant price - don't override if we are
  if (priceContainer.getAttribute('data-showing-variant-price') === 'true') {
    return;
  }
  
  // Reset the data attribute
  priceContainer.removeAttribute('data-showing-variant-price');
  priceContainer.removeAttribute('data-variant-id');
  
  const priceElement = document.querySelector('#price-{{ section.id }} .price__regular .price-item--regular');
  if (!priceElement) return;
  
  // Only update if min and max prices are different
  if (productData.min_price !== productData.max_price) {
    const formattedMinPrice = formatPrice(productData.min_price);
    const formattedMaxPrice = formatPrice(productData.max_price);
    priceElement.textContent = `${formattedMinPrice} ~ ${formattedMaxPrice}`;
  }
}

// Also modify the change event handler to debounce the updates
select.addEventListener('change', function (e) {
  // Store the selection in both Map and localStorage
  const value = this.value;
  const isDefaultOption = value === '' || this.selectedIndex === 0;
  const selectedText = this.options[this.selectedIndex].text;

  // Update button state
  deselectButton.disabled = isDefaultOption;

  // Update class for styling
  if (isDefaultOption) {
    this.classList.remove('user-selected');
    selectContainer.classList.remove('text-mode');
  } else {
    this.classList.add('user-selected');
    selectContainer.classList.add('text-mode');
    selectedTextElement.textContent = selectedText;
  }

  // Save selection
  selectedOptions.set(`${sectionId}-${optionIndex}`, value);
  localStorage.setItem(`variant-${sectionId}-${optionIndex}`, value);

  // Hide warning if shown
  hideVariantWarning(sectionId);

  // Dispatch custom event if placeholder is chosen
  if (isDefaultOption) {
    this.dispatchEvent(pleaseSelectEvent);
  }
  
  // Clear any pending timeouts to avoid multiple updates
  if (window.priceUpdateTimeout) {
    clearTimeout(window.priceUpdateTimeout);
  }
  
  // Update price based on current selections with a delay
  window.priceUpdateTimeout = setTimeout(() => {
    updatePriceBasedOnSelections(sectionId);
  }, 50);
});

// Also modify the deselect button handler
deselectButton.addEventListener('click', function (e) {
  e.preventDefault();
  e.stopPropagation();

  // Reset to placeholder
  select.selectedIndex = 0;
  this.disabled = true;
  select.classList.remove('user-selected');

  // Switch back to dropdown mode
  selectContainer.classList.remove('text-mode');

  // Update stored values
  selectedOptions.delete(`${sectionId}-${optionIndex}`);
  localStorage.removeItem(`variant-${sectionId}-${optionIndex}`);

  // Dispatch events
  const changeEvent = new Event('change', { bubbles: true });
  select.dispatchEvent(changeEvent);
  select.dispatchEvent(pleaseSelectEvent);
  
  // Clear any price data attributes
  const priceContainer = document.querySelector('#price-{{ section.id }}');
  if (priceContainer) {
    priceContainer.removeAttribute('data-showing-variant-price');
    priceContainer.removeAttribute('data-variant-id');
  }
  
  // Clear any pending timeouts
  if (window.priceUpdateTimeout) {
    clearTimeout(window.priceUpdateTimeout);
  }
  
  // Update price to show range
  window.priceUpdateTimeout = setTimeout(() => {
    showPriceRange();
  }, 50);
});

// Modify the variant:changed handler to respect the current state
const variantChangedHandler = () => {
  setTimeout(() => {
    // Only override if we want this to stay at placeholder
    const savedValue = localStorage.getItem(`variant-${sectionId}-${optionIndex}`);
    if (savedValue === '' && select.selectedIndex !== 0) {
      select.selectedIndex = 0;
      select.dispatchEvent(new Event('change', { bubbles: true }));
    }

    // Update text mode
    const isDefaultOption = select.value === '' || select.selectedIndex === 0;
    if (!isDefaultOption) {
      selectContainer.classList.add('text-mode');
      selectedTextElement.textContent = select.options[select.selectedIndex].text;
    } else {
      selectContainer.classList.remove('text-mode');
    }
    
    // Check if we should update price
    const priceContainer = document.querySelector('#price-{{ section.id }}');
    if (priceContainer && priceContainer.getAttribute('data-showing-variant-price') !== 'true') {
      // Only update price if we're not already showing a specific variant price
      updatePriceBasedOnSelections(sectionId);
    }
  }, 10);
};

// Update the DOMContentLoaded handler to eliminate unnecessary price updates
document.addEventListener('DOMContentLoaded', function () {
  // Initialize product data first
  initializeProductData();
  
  // Then initialize variant selectors
  initializeVariantSelectors();
  overrideVariantSelection();
  
  // Show initial price based on selections - just once
  const variantSelects = document.querySelector('variant-selects');
  if (variantSelects) {
    const sectionId = variantSelects.dataset.section;
    if (sectionId) {
      // Check if any variants are selected already
      const hasSelections = checkAnyVariantsSelected(sectionId);
      
      if (hasSelections) {
        updatePriceBasedOnSelections(sectionId);
      } else {
        showPriceRange();
      }
    }
  }
  
  // Add a new helper function to check if any variants are selected
  function checkAnyVariantsSelected(sectionId) {
    const selects = document.querySelectorAll(`#variant-selects-${sectionId} select`);
    for (let i = 0; i < selects.length; i++) {
      const select = selects[i];
      if (select.selectedIndex > 0 && select.value !== '') {
        return true;
      }
    }
    return false;
  }
});