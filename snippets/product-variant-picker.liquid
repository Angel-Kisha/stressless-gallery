{% comment %}
  Renders product variant-picker with warning message for incomplete selections

  Accepts:
  - product: {Object} product object.
  - block: {Object} passing the block information.
  - product_form_id: {String} Id of the product form to which the variant picker is associated.
  Usage:
  {% render 'product-variant-picker', product: product, block: block, product_form_id: product_form_id %}
{% endcomment %}
{%- unless product.has_only_default_variant -%}
  <variant-selects
    id="variant-selects-{{ section.id }}"
    data-section="{{ section.id }}"
    {{ block.shopify_attributes }}
  >
    {%- for option in product.options_with_values -%}
      {%- liquid
        assign swatch_count = option.values | map: 'swatch' | compact | size
        assign picker_type = block.settings.picker_type

        if swatch_count > 0 and block.settings.swatch_shape != 'none'
          if block.settings.picker_type == 'dropdown'
            assign picker_type = 'swatch_dropdown'
          else
            assign picker_type = 'swatch'
          endif
        endif
      -%}
      {%- if picker_type == 'swatch' -%}
        <fieldset class="js product-form__input product-form__input--swatch">
          <legend class="form__label">
            {{ option.name }}:
            <span data-selected-value>
              {{- option.selected_value -}}
            </span>
          </legend>
          {% render 'product-variant-options',
            product: product,
            option: option,
            block: block,
            picker_type: picker_type
          %}
        </fieldset>
      {%- elsif picker_type == 'button' -%}
        <fieldset class="js product-form__input product-form__input--pill">
          <legend class="form__label">{{ option.name }}</legend>
          {% render 'product-variant-options',
            product: product,
            option: option,
            block: block,
            picker_type: picker_type
          %}
        </fieldset>
      {%- else -%}
        <div class="product-form__input product-form__input--dropdown product-label-dropdown">
          <label
            class="w-30 form__label product-label-dropdown-text"
            for="Option-{{ section.id }}-{{ forloop.index0 }}"
          >
            {{ option.name }}
          </label>

          <!-- Original select dropdown -->
          <div class="select-container w-55">
            <div class="select select-dropdown-container">
              {%- if picker_type == 'swatch_dropdown' -%}
                <span
                  data-selected-value
                  class="dropdown-swatch"
                >
                  {% render 'swatch', swatch: option.selected_value.swatch, shape: block.settings.swatch_shape %}
                </span>
              {%- endif -%}
              <select
                id="Option-{{ section.id }}-{{ forloop.index0 }}"
                class="select__select please-select-enabled"
                name="options[{{ option.name | escape }}]"
                form="{{ product_form_id }}"
                data-option-index="{{ forloop.index0 }}"
                data-default-unselected="true"
                data-required="true"
              >
                {% render 'product-variant-options',
                  product: product,
                  option: option,
                  block: block,
                  picker_type: picker_type
                %}
              </select>
              <span class="svg-wrapper">
                {{- 'icon-caret.svg' | inline_asset_content -}}
              </span>
            </div>

            <!-- Plain text display for selected value -->
            <div class="selected-value-display">
              <span class="selected-text"></span>
            </div>
          </div>

          <div class="divider"></div>
          <div class="w-15">
            <button type="button" disabled class="deselect-button" disabled>選択解除</button>
          </div>
        </div>
      {%- endif -%}
    {%- endfor -%}

    <div id="variant-selection-warning-{{ section.id }}" class="variant-selection-warning" style="display: none;">
      <div class="warning-content">
        <span class="warning-icon">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="16"
            height="16"
            viewBox="0 0 16 16"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
          >
            <circle cx="8" cy="8" r="7"></circle>
            <line x1="8" y1="5" x2="8" y2="9"></line>
            <line x1="8" y1="12" x2="8.01" y2="12"></line>
          </svg>
        </span>
        <p>上記項目を選択してください</p>
      </div>
    </div>

    <!-- Add hidden price range container -->
    <div id="price-range-container-{{ section.id }}" class="price-range-container" style="display: none;">
      {%- liquid
        assign min_price = product.price_min | money
        assign max_price = product.price_max | money
        if product.price_varies
          assign price_range = min_price | append: ' ~ ' | append: max_price
        else
          assign price_range = min_price
        endif
      -%}
      <div class="price price--large">
        <span class="price-item price-item--regular">{{ price_range }}</span>
      </div>
    </div>

    <script type="application/json" data-selected-variant>
      {{ product.selected_or_first_available_variant | json }}
    </script>
  </variant-selects>

  <style>
    .deselect-button:not(:disabled):hover {
      opacity: 0.5;
    }

    .deselect-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Force the select to maintain its selection */
    .select__select.user-selected {
      border-color: #4a90e2;
    }

    /* Hide the default option from dropdown list */
    .select__select option.placeholder-option {
      display: none;
    }

    /* Styles for the text display mode */
    .select-container {
      position: relative;
    }

    /* This is where selected text will appear */
    .selected-value-display {
      padding: 0 31px 0 20px;
      min-height: 40px;
      align-items: center;
      display: none;
      width: 100%;
    }

    .selected-text {
      font-size: small;
      font-weight: 500;
      color: #ffffffbf;
    }

    /* Toggle visibility based on text mode */
    .select-container.text-mode .select-dropdown-container {
      display: none;
    }

    .select-container.text-mode .selected-value-display {
      display: flex;
    }

    .variant-selection-warning {
      margin-top: 15px;
      padding: 10px;
      background-color: rgba(255, 0, 0, 0.1);
      border: 1px solid rgba(255, 0, 0, 0.3);
      border-radius: 4px;
      color: #d00;
      text-align: center;
    }

    .warning-content {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    .warning-icon {
      display: flex;
      align-items: center;
      color: #d00;
    }

    .variant-selection-warning p {
      margin: 0;
      font-size: 14px;
    }

    /* Add a shake animation for the warning */
    @keyframes warning-shake {
      0% {
        transform: translateX(0);
      }
      25% {
        transform: translateX(-5px);
      }
      50% {
        transform: translateX(5px);
      }
      75% {
        transform: translateX(-5px);
      }
      100% {
        transform: translateX(0);
      }
    }

    .warning-shake {
      animation: warning-shake 0.5s ease-in-out;
    }
  </style>

  <script>
    (function () {
      // Constants
      const PLACEHOLDER_TEXT = '選択してください';

      // Track which options have been selected
      const selectedOptions = {};

      // Debounce timer for price updates
      let priceUpdateTimer = null;

      // Initialize elements and set up events
      function init() {
        const variantSections = document.querySelectorAll('variant-selects');

        variantSections.forEach((section) => {
          const sectionId = section.dataset.section;
          if (!sectionId) return;

          // Set up price range container immediately but don't update yet
          const priceContainer = document.getElementById(`price-${sectionId}`);
          const priceRangeContainer = document.getElementById(`price-range-container-${sectionId}`);

          if (priceContainer && priceRangeContainer && !priceRangeContainer.dataset.initialized) {
            // Clone the price range content for reference
            priceRangeContainer.dataset.initialized = 'true';
            priceRangeContainer.dataset.priceRange = priceRangeContainer.innerHTML;
          }

          // Initialize all selects in this section
          const selects = section.querySelectorAll('select[data-required="true"]');
          selects.forEach(setupSelect);

          // Initial price update
          requestAnimationFrame(() => {
            updatePriceDisplay(sectionId);
          });
        });

        // Add event listeners for variant changes
        document.addEventListener('variant:changed', handleVariantChange);

        // Set up add to cart button validation
        document.addEventListener('click', validateAddToCart, true);
      }

      // Set up a single select element
      function setupSelect(select) {
        if (select.hasAttribute('data-initialized')) return;
        select.setAttribute('data-initialized', 'true');

        // Find container elements
        const container = select.closest('.product-form__input--dropdown');
        if (!container) return;

        const deselectButton = container.querySelector('.deselect-button');
        const selectContainer = container.querySelector('.select-container');
        const textDisplay = selectContainer?.querySelector('.selected-text');

        if (!deselectButton || !selectContainer || !textDisplay) return;

        // Get identifiers
        const sectionId = select.id.split('-')[1];
        const optionIndex = select.dataset.optionIndex;
        const selectId = `${sectionId}-${optionIndex}`;

        // Ensure placeholder option exists
        ensurePlaceholderOption(select);

        // Restore saved selection if any
        const savedValue = localStorage.getItem(`variant-${selectId}`);
        if (savedValue && savedValue !== '') {
          for (let i = 0; i < select.options.length; i++) {
            if (select.options[i].value === savedValue) {
              select.selectedIndex = i;
              deselectButton.disabled = false;
              select.classList.add('user-selected');
              selectContainer.classList.add('text-mode');
              textDisplay.textContent = select.options[i].text;

              // Store in memory
              selectedOptions[selectId] = savedValue;
              break;
            }
          }
        } else {
          // Ensure placeholder is selected
          select.selectedIndex = 0;
          deselectButton.disabled = true;
          select.classList.remove('user-selected');
          selectContainer.classList.remove('text-mode');
          delete selectedOptions[selectId];
        }

        // Set up change event
        select.addEventListener('change', function () {
          const value = this.value;
          const isDefault = value === '' || this.selectedIndex === 0;
          const selectedText = this.options[this.selectedIndex].text;

          // Update UI
          if (isDefault) {
            this.classList.remove('user-selected');
            selectContainer.classList.remove('text-mode');
            deselectButton.disabled = true;
            delete selectedOptions[selectId];
            localStorage.removeItem(`variant-${selectId}`);
          } else {
            this.classList.add('user-selected');
            selectContainer.classList.add('text-mode');
            textDisplay.textContent = selectedText;
            deselectButton.disabled = false;
            selectedOptions[selectId] = value;
            localStorage.setItem(`variant-${selectId}`, value);
          }

          // Schedule price update with debounce
          requestAnimationFrame(() => {
            updatePriceDisplay(sectionId);
          });

          // Hide any warning
          hideVariantWarning(sectionId);
        });

        // Set up deselect button
        deselectButton.addEventListener('click', function (e) {
          e.preventDefault();
          e.stopPropagation();

          // Reset select to placeholder
          select.selectedIndex = 0;
          select.classList.remove('user-selected');
          selectContainer.classList.remove('text-mode');
          this.disabled = true;

          // Clear stored values
          delete selectedOptions[selectId];
          localStorage.removeItem(`variant-${selectId}`);

          // Schedule price update
          requestAnimationFrame(() => {
            updatePriceDisplay(sectionId, true);
          });

          // Dispatch change event
          select.dispatchEvent(new Event('change', { bubbles: true }));
        });
      }

      // Make sure placeholder option exists
      function ensurePlaceholderOption(select) {
        let placeholderOption = null;

        // Check if it already exists
        for (let i = 0; i < select.options.length; i++) {
          if (select.options[i].value === '' || select.options[i].classList.contains('placeholder-option')) {
            placeholderOption = select.options[i];
            break;
          }
        }

        if (!placeholderOption) {
          // Create new placeholder
          placeholderOption = new Option(PLACEHOLDER_TEXT, '', true, false);
          placeholderOption.classList.add('placeholder-option');
          select.insertBefore(placeholderOption, select.firstChild);
        } else {
          // Update existing placeholder
          placeholderOption.text = PLACEHOLDER_TEXT;
          placeholderOption.classList.add('placeholder-option');
        }
      }

      // Handle variant change events
      function handleVariantChange(e) {
        // Find section ID
        let sectionId = null;
        if (e.target && e.target.dataset && e.target.dataset.section) {
          sectionId = e.target.dataset.section;
        } else if (e.detail && e.detail.sectionId) {
          sectionId = e.detail.sectionId;
        }

        // Update price display in next animation frame
        if (sectionId) {
          requestAnimationFrame(() => {
            updatePriceDisplay(sectionId);
          });
        } else {
          requestAnimationFrame(() => {
            document.querySelectorAll('variant-selects').forEach((section) => {
              if (section.dataset.section) {
                updatePriceDisplay(section.dataset.section);
              }
            });
          });
        }
      }

      // Cache for variant prices
      const variantPriceCache = {};

      // Update price display based on selections
      function updatePriceDisplay(sectionId, forceRange = false) {
        // Clear any pending update
        if (priceUpdateTimer) {
          clearTimeout(priceUpdateTimer);
        }

        const priceContainer = document.getElementById(`price-${sectionId}`);
        const priceRangeContainer = document.getElementById(`price-range-container-${sectionId}`);

        if (!priceContainer || !priceRangeContainer) return;

        // Get price range content
        const priceRangeContent = priceRangeContainer.dataset.priceRange || priceRangeContainer.innerHTML;

        // Check if all variants are selected
        const allSelected = areAllVariantsSelected(sectionId);

        if (forceRange || !allSelected) {
          // For range price, use the stored content
          const currentContent = priceContainer.innerHTML;
          const hasRange = currentContent.includes('~');

          // Only update if needed
          if (!hasRange) {
            // Store current price display to avoid flicker
            if (currentContent) {
              priceContainer.dataset.previousContent = currentContent;
            }

            // Update to range price
            priceContainer.innerHTML = priceRangeContent;
          }
        } else {
          // All variants selected - get variant price
          const variantSelects = document.getElementById(`variant-selects-${sectionId}`);
          if (!variantSelects) return;

          try {
            const variantDataElement = variantSelects.querySelector('[data-selected-variant]');
            if (!variantDataElement) return;

            const variantData = JSON.parse(variantDataElement.textContent);
            if (!variantData || !variantData.price) return;

            // Create cache key based on variant ID
            const cacheKey = `variant-${variantData.id}`;

            // Check cache first
            if (variantPriceCache[cacheKey]) {
              const cachedHTML = variantPriceCache[cacheKey];

              // Only update if different
              if (priceContainer.innerHTML !== cachedHTML) {
                priceContainer.innerHTML = cachedHTML;
              }
            } else {
              // Format price
              const formattedPrice = formatPrice(variantData.price);

              // Create HTML
              const priceHTML = `<div class="price price--large">
            <span class="price-item price-item--regular">${formattedPrice}</span>
          </div>`;

              // Cache the result
              variantPriceCache[cacheKey] = priceHTML;

              // Update the DOM
              if (priceContainer.innerHTML !== priceHTML) {
                priceContainer.innerHTML = priceHTML;
              }
            }
          } catch (e) {
            console.error('Error updating variant price:', e);
          }
        }
      }

      // Format price consistently
      function formatPrice(price) {
        return new Intl.NumberFormat('ja-JP', {
          style: 'currency',
          currency: 'JPY',
          minimumFractionDigits: 0,
        })
          .format(price / 100)
          .replace('JP¥', '¥');
      }

      // Check if all required variants are selected
      function areAllVariantsSelected(sectionId) {
        const selects = document.querySelectorAll(`#variant-selects-${sectionId} select[data-required="true"]`);
        for (const select of selects) {
          if (select.selectedIndex === 0 || select.value === '') {
            return false;
          }
        }
        return true;
      }

      // Show warning when variants not selected
      function showVariantWarning(sectionId) {
        const warning = document.getElementById(`variant-selection-warning-${sectionId}`);
        if (warning) {
          warning.style.display = 'block';
          warning.classList.add('warning-shake');

          setTimeout(() => warning.classList.remove('warning-shake'), 500);
          warning.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
      }

      // Hide warning
      function hideVariantWarning(sectionId) {
        const warning = document.getElementById(`variant-selection-warning-${sectionId}`);
        if (warning) {
          warning.style.display = 'none';
        }
      }

      // Validate add to cart button click
      function validateAddToCart(e) {
        const addToCartButton = e.target.closest('.product-form__submit');
        if (!addToCartButton) return;

        const productForm = addToCartButton.closest('product-form');
        if (!productForm) return;

        const sectionId = productForm.dataset.section;
        if (!sectionId) return;

        // Check all variants selected
        if (!areAllVariantsSelected(sectionId)) {
          e.preventDefault();
          e.stopPropagation();
          showVariantWarning(sectionId);
        } else {
          hideVariantWarning(sectionId);
        }
      }

      // Initialize on DOM ready
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
      } else {
        init();
      }

      // Watch for DOM changes to catch late-loading elements
      const observer = new MutationObserver((mutations) => {
        for (const mutation of mutations) {
          if (mutation.type === 'childList' && mutation.addedNodes.length) {
            for (const node of mutation.addedNodes) {
              if (node.nodeType === 1 && (node.tagName === 'SELECT' || node.querySelector('select'))) {
                setTimeout(init, 10); // Re-initialize with slight delay
                return;
              }
            }
          }
        }
      });

      observer.observe(document.body, {
        childList: true,
        subtree: true,
      });
    })();
  </script>
{%- endunless -%}
